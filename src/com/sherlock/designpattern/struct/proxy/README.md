# Proxy
> 在不改变原始类代码的情况下，通过引入代理类来给原始类附加功能。

## 接口
定义接口[IA](./IA.java),业务实现类[A](./A.java),代理类[AProxy](./AProxy.java)。
代理类通过委托的方式，实现业务功能。
```java
    IA a = new AProxy(new A());
```
但是如果原代码不是我们维护的时候，此方法就无法实现。
## 继承
业务实现类[B](./B.java),代理类[BProxy](./BProxy.java)。
利用继承，让代理类对原类进行功能拓展。
```java
    B b = new BProxy();
```
但是此方法还是存在不足，一方面需要在代理类中将原始类中的方法全部重新实现一遍，
另一方面如果添加功能类不止一个，则需要创建更多的代理类。
## 动态代理
针对上面两种方式存在的问题，可以使用动态代理来解决。即事先不为每个类编写代理类，
但是在代码运行时，动态地为原始类创建对应的代理类，然后进行替换。

Java中实现动态代理十分简单，因为Java提供动态代理的语法，动态代理的底层依赖于
Java 的反射语法。

Spring AOP底层实现就是基于动态代理。用户配置好需要给那些类创建代理，并定义
好在执行原始类的代码前后执行哪些附加功能。
## 应用场景
### 1. 业务系统的非功能性需求开发
- 监控
- 统计
- 鉴权
- 限流
- 事务
- 幂等
- 日志等

### 2. RPC、缓存
- RPC框架也可以看作一种代理模式。通过远程代理，将网络通信、数据编解码等细节隐藏起来。'
  客户端使用RPC服务时，就像使用本地函数一样。
- 某个接口在指定时间内，如果入参相同的前提下，结果相同。那么就可以将该结果进行缓存，
  指定过期时间。该接口被调用时，如果存在缓存则直接返回，不存在就调用。